/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

<<<<<<< HEAD
module.exports = proxyaddr
module.exports.all = alladdrs
module.exports.compile = compile
=======
module.exports = proxyaddr;
module.exports.all = alladdrs;
module.exports.compile = compile;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

/**
 * Module dependencies.
 * @private
 */

<<<<<<< HEAD
var forwarded = require('forwarded')
var ipaddr = require('ipaddr.js')
=======
var forwarded = require('forwarded');
var ipaddr = require('ipaddr.js');
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

/**
 * Variables.
 * @private
 */

<<<<<<< HEAD
var DIGIT_REGEXP = /^[0-9]+$/
var isip = ipaddr.isValid
var parseip = ipaddr.parse
=======
var digitre = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

/**
 * Pre-defined IP ranges.
 * @private
 */

<<<<<<< HEAD
var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
}
=======
var ipranges = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
};
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @public
 */

<<<<<<< HEAD
function alladdrs (req, trust) {
  // get addresses
  var addrs = forwarded(req)

  if (!trust) {
    // Return all addresses
    return addrs
  }

  if (typeof trust !== 'function') {
    trust = compile(trust)
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue

    addrs.length = i + 1
  }

  return addrs
=======
function alladdrs(req, trust) {
  // get addresses
  var addrs = forwarded(req);

  if (!trust) {
    // Return all addresses
    return addrs;
  }

  if (typeof trust !== 'function') {
    trust = compile(trust);
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;

    addrs.length = i + 1;
  }

  return addrs;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

<<<<<<< HEAD
function compile (val) {
  if (!val) {
    throw new TypeError('argument is required')
  }

  var trust

  if (typeof val === 'string') {
    trust = [val]
  } else if (Array.isArray(val)) {
    trust = val.slice()
  } else {
    throw new TypeError('unsupported trust argument')
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i]

    if (!IP_RANGES.hasOwnProperty(val)) {
      continue
    }

    // Splice in pre-defined range
    val = IP_RANGES[val]
    trust.splice.apply(trust, [i, 1].concat(val))
    i += val.length - 1
  }

  return compileTrust(compileRangeSubnets(trust))
=======
function compile(val) {
  if (!val) {
    throw new TypeError('argument is required');
  }

  var trust;

  if (typeof val === 'string') {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError('unsupported trust argument');
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i];

    if (!ipranges.hasOwnProperty(val)) {
      continue;
    }

    // Splice in pre-defined range
    val = ipranges[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }

  return compileTrust(compileRangeSubnets(trust));
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

<<<<<<< HEAD
function compileRangeSubnets (arr) {
  var rangeSubnets = new Array(arr.length)

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i])
  }

  return rangeSubnets
=======
function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }

  return rangeSubnets;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

<<<<<<< HEAD
function compileTrust (rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length
=======
function compileTrust(rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
  return len === 0
    ? trustNone
    : len === 1
    ? trustSingle(rangeSubnets[0])
<<<<<<< HEAD
    : trustMulti(rangeSubnets)
=======
    : trustMulti(rangeSubnets);
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

<<<<<<< HEAD
function parseipNotation (note) {
  var pos = note.lastIndexOf('/')
  var str = pos !== -1
    ? note.substring(0, pos)
    : note

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str)
  }

  var ip = parseip(str)

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address()
=======
function parseipNotation(note) {
  var pos = note.lastIndexOf('/');
  var str = pos !== -1
    ? note.substring(0, pos)
    : note;

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str);
  }

  var ip = parseip(str);

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address();
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
  }

  var max = ip.kind() === 'ipv6'
    ? 128
<<<<<<< HEAD
    : 32

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null

  if (range === null) {
    range = max
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10)
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range)
  } else {
    range = null
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note)
  }

  return [ip, range]
=======
    : 32;

  var range = pos !== -1
    ? note.substring(pos + 1, note.length)
    : null;

  if (range === null) {
    range = max;
  } else if (digitre.test(range)) {
    range = parseInt(range, 10);
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range);
  } else {
    range = null;
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note);
  }

  return [ip, range];
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

<<<<<<< HEAD
function parseNetmask (netmask) {
  var ip = parseip(netmask)
  var kind = ip.kind()

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null
=======
function parseNetmask(netmask) {
  var ip = parseip(netmask);
  var kind = ip.kind();

  return kind === 'ipv4'
    ? ip.prefixLengthFromSubnetMask()
    : null;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

<<<<<<< HEAD
function proxyaddr (req, trust) {
  if (!req) {
    throw new TypeError('req argument is required')
  }

  if (!trust) {
    throw new TypeError('trust argument is required')
  }

  var addrs = alladdrs(req, trust)
  var addr = addrs[addrs.length - 1]

  return addr
=======
function proxyaddr(req, trust) {
  if (!req) {
    throw new TypeError('req argument is required');
  }

  if (!trust) {
    throw new TypeError('trust argument is required');
  }

  var addrs = alladdrs(req, trust);
  var addr = addrs[addrs.length - 1];

  return addr;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

<<<<<<< HEAD
function trustNone () {
  return false
=======
function trustNone() {
  return false;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

<<<<<<< HEAD
function trustMulti (subnets) {
  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var ipconv
    var kind = ip.kind()

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i]
      var subnetip = subnet[0]
      var subnetkind = subnetip.kind()
      var subnetrange = subnet[1]
      var trusted = ip
=======
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var ipconv;
    var kind = ip.kind();

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
<<<<<<< HEAD
          continue
=======
          continue;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4'
            ? ip.toIPv4Address()
<<<<<<< HEAD
            : ip.toIPv4MappedAddress()
        }

        trusted = ipconv
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true
      }
    }

    return false
  }
=======
            : ip.toIPv4MappedAddress();
        }

        trusted = ipconv;
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }

    return false;
  };
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

<<<<<<< HEAD
function trustSingle (subnet) {
  var subnetip = subnet[0]
  var subnetkind = subnetip.kind()
  var subnetisipv4 = subnetkind === 'ipv4'
  var subnetrange = subnet[1]

  return function trust (addr) {
    if (!isip(addr)) return false

    var ip = parseip(addr)
    var kind = ip.kind()
=======
function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === 'ipv4';
  var subnetrange = subnet[1];

  return function trust(addr) {
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var kind = ip.kind();
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
<<<<<<< HEAD
        return false
=======
        return false;
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4
        ? ip.toIPv4Address()
<<<<<<< HEAD
        : ip.toIPv4MappedAddress()
    }

    return ip.match(subnetip, subnetrange)
  }
=======
        : ip.toIPv4MappedAddress();
    }

    return ip.match(subnetip, subnetrange);
  };
>>>>>>> 4c26a242c3c2a1ff6742884e929760cedadbb8c9
}
